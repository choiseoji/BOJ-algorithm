[처음 생각한 풀이]
- 시작 위치에서 갈 수 있는 가장 빠른 더러운 곳을 bfs로 찾음.
- 그 위치를 시작으로 또 bfs로 찾음..
- 이렇게 나온 수를 다 합치면 답

-> 문제점 : 거리가 똑같은 곳이 여러개이면 어느 쪽을 가야 더 빠르게 갈 수 있을지 확인을 하지 못 한다.

</br>

[풀이]
- 점과 점 사이의 거리는 변하지 않으므로 일단 dist[i][j] 배열에 i 점에서 j 점까지 가는 거리를 계산해서 저장해둔다.
- 부르트포스로 모든 점을 가는 경우의 수를 다 구한 후, 경우의 수에 맞는 노드 방문 순서로 dist배열에서 값을 가져와서 다 더한 후, 기존 답보다 값이 작으면 답으로 갱신시켜주면 된다.
- 부르트포스(모든 점을 방문하는 순서 정하기) + bfs (점과 점사이의 최단 거리)



</br>



[반례]

5 5

....*

.*.*.

..o..

..*..

.....

answer: 8

-> 이 경우에 4번째 줄 *을 갔다가 두번째 줄 *을 가야하는데 두 *까지의 거리가 같다.
근데 사실 최단 거리로 가려면 왼쪽에 있는 *을 먼저 가야하는데 이에 대한 처리가 부족하다 ..ㅠㅠㅠ 어떻게 해주면 좋을까?

6 5

.....*

.*..*.

...o..

.*....

......

answer: 10
